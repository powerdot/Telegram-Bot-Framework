/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/minisearch@4.0.3/dist/umd/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).MiniSearch = t() }(this, (function () {
    "use strict";
 /*! *****************************************************************************
     Copyright (c) Microsoft Corporation.
 
     Permission to use, copy, modify, and/or distribute this software for any
     purpose with or without fee is hereby granted.
 
     THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
     REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
     AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
     INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
     LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
     OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
     PERFORMANCE OF THIS SOFTWARE.
     ***************************************************************************** */var e = function () { return e = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++)for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, e.apply(this, arguments) }; function t(e) { var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } function r(e, t) { var r = "function" == typeof Symbol && e[Symbol.iterator]; if (!r) return e; var n, i, o = r.call(e), u = []; try { for (; (void 0 === t || t-- > 0) && !(n = o.next()).done;)u.push(n.value) } catch (e) { i = { error: e } } finally { try { n && !n.done && (r = o.return) && r.call(o) } finally { if (i) throw i.error } } return u } function n(e, t, r) { if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++)!n && i in t || (n || (n = Array.prototype.slice.call(t, 0, i)), n[i] = t[i]); return e.concat(n || Array.prototype.slice.call(t)) } var i, o = "KEYS", u = "VALUES", a = "", s = function () { function e(e, t) { var r = e._tree, n = Array.from(r.keys()); this.set = e, this._type = t, this._path = n.length > 0 ? [{ node: r, keys: n }] : [] } return e.prototype.next = function () { var e = this.dive(); return this.backtrack(), e }, e.prototype.dive = function () { if (0 === this._path.length) return { done: !0, value: void 0 }; var e = l(this._path), t = e.node, r = e.keys; return l(r) === a ? { done: !1, value: this.result() } : (this._path.push({ node: t.get(l(r)), keys: Array.from(t.get(l(r)).keys()) }), this.dive()) }, e.prototype.backtrack = function () { 0 !== this._path.length && (l(this._path).keys.pop(), l(this._path).keys.length > 0 || (this._path.pop(), this.backtrack())) }, e.prototype.key = function () { return this.set._prefix + this._path.map((function (e) { var t = e.keys; return l(t) })).filter((function (e) { return e !== a })).join("") }, e.prototype.value = function () { return l(this._path).node.get(a) }, e.prototype.result = function () { return this._type === u ? this.value() : this._type === o ? this.key() : [this.key(), this.value()] }, e.prototype[Symbol.iterator] = function () { return this }, e }(), l = function (e) { return e[e.length - 1] }, f = function (e, r, n, i, o, u, s, l) { var c, h; try { e: for (var d = t(e.keys()), v = d.next(); !v.done; v = d.next()) { var y = v.value; if (y === a) { var p = o[u - 1]; p <= n && i.set(l, [e.get(y), p]) } else { for (var m = 0; m < y.length; m++) { for (var F = y[m], g = u + s * m, x = g - s, _ = o[g] = o[x] + 1, w = 0; w < s - 1; w++) { var A = F !== r[w], E = o[x + w] + +A, z = o[x + w + 1] + 1, b = o[g + w] + 1, C = o[g + w + 1] = Math.min(E, z, b); C < _ && (_ = C) } if (_ > n) continue e } f(e.get(y), r, n, i, o, u + s * y.length, s, l + y) } } } catch (e) { c = { error: e } } finally { try { v && !v.done && (h = d.return) && h.call(d) } finally { if (c) throw c.error } } }, c = function () { function e(e, t) { void 0 === e && (e = new Map), void 0 === t && (t = ""), this._size = void 0, this._tree = e, this._prefix = t } return e.prototype.atPrefix = function (n) { var i, o; if (!n.startsWith(this._prefix)) throw new Error("Mismatched prefix"); var u = r(h(this._tree, n.slice(this._prefix.length)), 2), s = u[0], l = u[1]; if (void 0 === s) { var f = r(g(l), 2), c = f[0], d = f[1]; try { for (var v = t(c.keys()), y = v.next(); !y.done; y = v.next()) { var p = y.value; if (p !== a && p.startsWith(d)) { var m = new Map; return m.set(p.slice(d.length), c.get(p)), new e(m, n) } } } catch (e) { i = { error: e } } finally { try { y && !y.done && (o = v.return) && o.call(v) } finally { if (i) throw i.error } } } return new e(s, n) }, e.prototype.clear = function () { this._size = void 0, this._tree.clear() }, e.prototype.delete = function (e) { return this._size = void 0, p(this._tree, e) }, e.prototype.entries = function () { return new s(this, "ENTRIES") }, e.prototype.forEach = function (e) { var n, i; try { for (var o = t(this), u = o.next(); !u.done; u = o.next()) { var a = r(u.value, 2); e(a[0], a[1], this) } } catch (e) { n = { error: e } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, e.prototype.fuzzyGet = function (e, t) { return function (e, t, r) { var n = new Map; if (void 0 === t) return n; for (var i = t.length + 1, o = new Uint8Array((i + r) * i), u = 0; u < i; u++)o[u] = u; return f(e, t, r, n, o, i, i, ""), n }(this._tree, e, t) }, e.prototype.get = function (e) { var t = d(this._tree, e); return void 0 !== t ? t.get(a) : void 0 }, e.prototype.has = function (e) { var t = d(this._tree, e); return void 0 !== t && t.has(a) }, e.prototype.keys = function () { return new s(this, o) }, e.prototype.set = function (e, t) { if ("string" != typeof e) throw new Error("key must be a string"); return this._size = void 0, v(this._tree, e).set(a, t), this }, Object.defineProperty(e.prototype, "size", { get: function () { if (this._size) return this._size; this._size = 0; for (var e = this.entries(); !e.next().done;)this._size += 1; return this._size }, enumerable: !1, configurable: !0 }), e.prototype.update = function (e, t) { if ("string" != typeof e) throw new Error("key must be a string"); this._size = void 0; var r = v(this._tree, e); return r.set(a, t(r.get(a))), this }, e.prototype.fetch = function (e, t) { if ("string" != typeof e) throw new Error("key must be a string"); this._size = void 0; var r = v(this._tree, e), n = r.get(a); return void 0 === n && r.set(a, n = t()), n }, e.prototype.values = function () { return new s(this, u) }, e.prototype[Symbol.iterator] = function () { return this.entries() }, e.from = function (n) { var i, o, u = new e; try { for (var a = t(n), s = a.next(); !s.done; s = a.next()) { var l = r(s.value, 2), f = l[0], c = l[1]; u.set(f, c) } } catch (e) { i = { error: e } } finally { try { s && !s.done && (o = a.return) && o.call(a) } finally { if (i) throw i.error } } return u }, e.fromObject = function (t) { return e.from(Object.entries(t)) }, e }(), h = function (e, r, n) { var i, o; if (void 0 === n && (n = []), 0 === r.length || null == e) return [e, n]; try { for (var u = t(e.keys()), s = u.next(); !s.done; s = u.next()) { var l = s.value; if (l !== a && r.startsWith(l)) return n.push([e, l]), h(e.get(l), r.slice(l.length), n) } } catch (e) { i = { error: e } } finally { try { s && !s.done && (o = u.return) && o.call(u) } finally { if (i) throw i.error } } return n.push([e, r]), h(void 0, "", n) }, d = function (e, r) { var n, i; if (0 === r.length || null == e) return e; try { for (var o = t(e.keys()), u = o.next(); !u.done; u = o.next()) { var s = u.value; if (s !== a && r.startsWith(s)) return d(e.get(s), r.slice(s.length)) } } catch (e) { n = { error: e } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, v = function (e, r) { var n, i, o, u; if (0 === r.length || null == e) return e; try { for (var s = t(e.keys()), l = s.next(); !l.done; l = s.next()) { if ((h = l.value) !== a && r.startsWith(h)) return v(e.get(h), r.slice(h.length)) } } catch (e) { n = { error: e } } finally { try { l && !l.done && (i = s.return) && i.call(s) } finally { if (n) throw n.error } } try { for (var f = t(e.keys()), c = f.next(); !c.done; c = f.next()) { var h; if ((h = c.value) !== a && h.startsWith(r[0])) { var d = y(r, h), p = new Map; return p.set(h.slice(d), e.get(h)), e.set(r.slice(0, d), p), e.delete(h), v(p, r.slice(d)) } } } catch (e) { o = { error: e } } finally { try { c && !c.done && (u = f.return) && u.call(f) } finally { if (o) throw o.error } } var m = new Map; return e.set(r, m), m }, y = function (e, t) { for (var r = Math.min(e.length, t.length), n = 0; n < r; n++)if (e[n] !== t[n]) return n; return r }, p = function (e, t) { var n = r(h(e, t), 2), i = n[0], o = n[1]; if (void 0 !== i) if (i.delete(a), 0 === i.size) m(o); else if (1 === i.size) { var u = r(i.entries().next().value, 2), s = u[0], l = u[1]; F(o, s, l) } }, m = function (e) { if (0 !== e.length) { var t = r(g(e), 2), n = t[0], i = t[1]; if (n.delete(i), 0 === n.size) m(e.slice(0, -1)); else if (1 === n.size) { var o = r(n.entries().next().value, 2), u = o[0], s = o[1]; u !== a && F(e.slice(0, -1), u, s) } } }, F = function (e, t, n) { if (0 !== e.length) { var i = r(g(e), 2), o = i[0], u = i[1]; o.set(u + t, n), o.delete(u) } }, g = function (e) { return e[e.length - 1] }, x = "or", _ = function () { function n(t) { if (null == (null == t ? void 0 : t.fields)) throw new Error('MiniSearch: option "fields" must be provided'); this._options = e(e(e({}, C), t), { searchOptions: e(e({}, k), t.searchOptions || {}) }), this._index = new c, this._documentCount = 0, this._documentIds = new Map, this._fieldIds = {}, this._fieldLength = new Map, this._averageFieldLength = [], this._nextId = 0, this._storedFields = new Map, this.addFields(this._options.fields) } return n.prototype.add = function (e) { var r, n, i, o, u = this._options, a = u.extractField, s = u.tokenize, l = u.processTerm, f = u.fields, c = u.idField, h = a(e, c); if (null == h) throw new Error('MiniSearch: document does not have ID field "'.concat(c, '"')); var d = this.addDocumentId(h); this.saveStoredFields(d, e); try { for (var v = t(f), y = v.next(); !y.done; y = v.next()) { var p = y.value, m = a(e, p); if (null != m) { var F = s(m.toString(), p), g = this._fieldIds[p]; this.addFieldLength(d, g, this.documentCount - 1, F.length); try { for (var x = (i = void 0, t(F)), _ = x.next(); !_.done; _ = x.next()) { var w = l(_.value, p); w && this.addTerm(g, d, w) } } catch (e) { i = { error: e } } finally { try { _ && !_.done && (o = x.return) && o.call(x) } finally { if (i) throw i.error } } } } } catch (e) { r = { error: e } } finally { try { y && !y.done && (n = v.return) && n.call(v) } finally { if (r) throw r.error } } }, n.prototype.addAll = function (e) { var r, n; try { for (var i = t(e), o = i.next(); !o.done; o = i.next()) { var u = o.value; this.add(u) } } catch (e) { r = { error: e } } finally { try { o && !o.done && (n = i.return) && n.call(i) } finally { if (r) throw r.error } } }, n.prototype.addAllAsync = function (e, t) { var r = this; void 0 === t && (t = {}); var n = t.chunkSize, i = void 0 === n ? 10 : n, o = { chunk: [], promise: Promise.resolve() }, u = e.reduce((function (e, t, n) { var o = e.chunk, u = e.promise; return o.push(t), (n + 1) % i == 0 ? { chunk: [], promise: u.then((function () { return new Promise((function (e) { return setTimeout(e, 0) })) })).then((function () { return r.addAll(o) })) } : { chunk: o, promise: u } }), o), a = u.chunk; return u.promise.then((function () { return r.addAll(a) })) }, n.prototype.remove = function (e) { var n, i, o, u, a, s, l = this._options, f = l.tokenize, c = l.processTerm, h = l.extractField, d = l.fields, v = l.idField, y = h(e, v); if (null == y) throw new Error('MiniSearch: document does not have ID field "'.concat(v, '"')); try { for (var p = t(this._documentIds), m = p.next(); !m.done; m = p.next()) { var F = r(m.value, 2), g = F[0]; if (y === F[1]) { try { for (var x = (o = void 0, t(d)), _ = x.next(); !_.done; _ = x.next()) { var w = _.value, A = h(e, w); if (null != A) { var E = f(A.toString(), w), z = this._fieldIds[w]; try { for (var b = (a = void 0, t(E)), C = b.next(); !C.done; C = b.next()) { var k = c(C.value, w); k && this.removeTerm(z, g, k) } } catch (e) { a = { error: e } } finally { try { C && !C.done && (s = b.return) && s.call(b) } finally { if (a) throw a.error } } this.removeFieldLength(g, z, this.documentCount, E.length) } } } catch (e) { o = { error: e } } finally { try { _ && !_.done && (u = x.return) && u.call(x) } finally { if (o) throw o.error } } return this._storedFields.delete(g), this._documentIds.delete(g), this._fieldLength.delete(g), void (this._documentCount -= 1) } } } catch (e) { n = { error: e } } finally { try { m && !m.done && (i = p.return) && i.call(p) } finally { if (n) throw n.error } } throw new Error("MiniSearch: cannot remove document with ID ".concat(y, ": it is not in the index")) }, n.prototype.removeAll = function (e) { var r, n; if (e) try { for (var i = t(e), o = i.next(); !o.done; o = i.next()) { var u = o.value; this.remove(u) } } catch (e) { r = { error: e } } finally { try { o && !o.done && (n = i.return) && n.call(i) } finally { if (r) throw r.error } } else { if (arguments.length > 0) throw new Error("Expected documents to be present. Omit the argument to remove all documents."); this._index = new c, this._documentCount = 0, this._documentIds = new Map, this._fieldLength = new Map, this._averageFieldLength = [], this._storedFields = new Map, this._nextId = 0 } }, n.prototype.search = function (e, n) { var i, o; void 0 === n && (n = {}); var u = this.executeQuery(e, n), a = []; try { for (var s = t(u), l = s.next(); !l.done; l = s.next()) { var f = r(l.value, 2), c = f[0], h = f[1], d = h.score, v = h.match, y = h.terms, p = { id: this._documentIds.get(c), terms: b(y), score: d, match: v }; Object.assign(p, this._storedFields.get(c)), (null == n.filter || n.filter(p)) && a.push(p) } } catch (e) { i = { error: e } } finally { try { l && !l.done && (o = s.return) && o.call(s) } finally { if (i) throw i.error } } return a.sort((function (e, t) { return e.score < t.score ? 1 : -1 })), a }, n.prototype.autoSuggest = function (n, i) { var o, u, a, s; void 0 === i && (i = {}), i = e(e({}, D), i); var l = new Map; try { for (var f = t(this.search(n, i)), c = f.next(); !c.done; c = f.next()) { var h = c.value, d = h.score, v = (_ = h.terms).join(" "); null != (g = l.get(v)) ? (g.score += d, g.count += 1) : l.set(v, { score: d, terms: _, count: 1 }) } } catch (e) { o = { error: e } } finally { try { c && !c.done && (u = f.return) && u.call(f) } finally { if (o) throw o.error } } var y = []; try { for (var p = t(l), m = p.next(); !m.done; m = p.next()) { var F = r(m.value, 2), g = F[0], x = F[1], _ = (d = x.score, x.terms), w = x.count; y.push({ suggestion: g, terms: _, score: d / w }) } } catch (e) { a = { error: e } } finally { try { m && !m.done && (s = p.return) && s.call(p) } finally { if (a) throw a.error } } return y.sort((function (e, t) { return e.score < t.score ? 1 : -1 })), y }, Object.defineProperty(n.prototype, "documentCount", { get: function () { return this._documentCount }, enumerable: !1, configurable: !0 }), n.loadJSON = function (e, t) { if (null == t) throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index"); return n.loadJS(JSON.parse(e), t) }, n.getDefault = function (e) { if (C.hasOwnProperty(e)) return w(C, e); throw new Error('MiniSearch: unknown option "'.concat(e, '"')) }, n.loadJS = function (e, i) { var o, u, a, s, l = e.index, f = e.documentCount, h = e.nextId, d = e.documentIds, v = e.fieldIds, y = e.fieldLength, p = e.averageFieldLength, m = e.storedFields; if (1 !== e.serializationVersion) throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version"); var F = new n(i); F._documentCount = f, F._nextId = h, F._documentIds = M(d), F._fieldIds = v, F._fieldLength = M(y), F._averageFieldLength = p, F._storedFields = M(m), F._index = new c; try { for (var g = t(l), x = g.next(); !x.done; x = g.next()) { var _ = r(x.value, 2), w = _[0], A = _[1], E = new Map; try { for (var z = (a = void 0, t(Object.keys(A))), b = z.next(); !b.done; b = z.next()) { var C = b.value, k = A[C], D = k.df, I = k.ds; E.set(parseInt(C, 10), { df: D, ds: M(I) }) } } catch (e) { a = { error: e } } finally { try { b && !b.done && (s = z.return) && s.call(z) } finally { if (a) throw a.error } } F._index.set(w, E) } } catch (e) { o = { error: e } } finally { try { x && !x.done && (u = g.return) && u.call(g) } finally { if (o) throw o.error } } return F }, n.prototype.executeQuery = function (t, r) { var n = this; if (void 0 === r && (r = {}), "string" == typeof t) return this.executeSearch(t, r); var i = t.queries.map((function (i) { var o = e(e(e({}, r), t), { queries: void 0 }); return n.executeQuery(i, o) })); return this.combineResults(i, t.combineWith) }, n.prototype.executeSearch = function (t, r) { var n = this; void 0 === r && (r = {}); var i = this._options, o = i.tokenize, u = i.processTerm, a = i.searchOptions, s = e(e({ tokenize: o, processTerm: u }, a), r), l = s.tokenize, f = s.processTerm, c = l(t).map((function (e) { return f(e) })).filter((function (e) { return !!e })).map(z(s)).map((function (e) { return n.executeQuerySpec(e, s) })); return this.combineResults(c, s.combineWith) }, n.prototype.executeQuerySpec = function (n, i) { var o, u, a, s, l, f, c = e(e({}, this._options.searchOptions), i), h = (c.fields || this._options.fields).reduce((function (t, r) { var n; return e(e({}, t), ((n = {})[r] = w(t, r) || 1, n)) }), c.boost || {}), d = c.boostDocument, v = c.weights, y = c.maxFuzzy, p = e(e({}, k.weights), v), m = p.fuzzy, F = p.prefix, g = this.termResults(n.term, h, d, this._index.get(n.term)); if (n.prefix && (l = this._index.atPrefix(n.term)), n.fuzzy) { var x = !0 === n.fuzzy ? .2 : n.fuzzy, _ = x < 1 ? Math.min(y, Math.round(n.term.length * x)) : x; f = this._index.fuzzyGet(n.term, _) } if (l) try { for (var A = t(l), E = A.next(); !E.done; E = A.next()) { var z = r(E.value, 2), b = z[0], C = z[1]; if (S = b.length - n.term.length) { null == f || f.delete(b); var D = .3 * S / b.length; this.termResults(b, h, d, C, g, F, D) } } } catch (e) { o = { error: e } } finally { try { E && !E.done && (u = A.return) && u.call(A) } finally { if (o) throw o.error } } if (f) try { for (var I = t(f.keys()), M = I.next(); !M.done; M = I.next()) { b = M.value; var S, O = r(f.get(b), 2); C = O[0]; if (S = O[1]) { D = S / b.length; this.termResults(b, h, d, C, g, m, D) } } } catch (e) { a = { error: e } } finally { try { M && !M.done && (s = I.return) && s.call(I) } finally { if (a) throw a.error } } return g }, n.prototype.combineResults = function (e, t) { if (void 0 === t && (t = x), 0 === e.length) return new Map; var r = t.toLowerCase(); return e.reduce(A[r]) || new Map }, n.prototype.toJSON = function () { var e, n, i, o, u = []; try { for (var a = t(this._index), s = a.next(); !s.done; s = a.next()) { var l = r(s.value, 2), f = l[0], c = l[1], h = {}; try { for (var d = (i = void 0, t(c)), v = d.next(); !v.done; v = d.next()) { var y = r(v.value, 2), p = y[0], m = y[1], F = m.df, g = m.ds; h[p] = { df: F, ds: Object.fromEntries(g) } } } catch (e) { i = { error: e } } finally { try { v && !v.done && (o = d.return) && o.call(d) } finally { if (i) throw i.error } } u.push([f, h]) } } catch (t) { e = { error: t } } finally { try { s && !s.done && (n = a.return) && n.call(a) } finally { if (e) throw e.error } } return { documentCount: this._documentCount, nextId: this._nextId, documentIds: Object.fromEntries(this._documentIds), fieldIds: this._fieldIds, fieldLength: Object.fromEntries(this._fieldLength), averageFieldLength: this._averageFieldLength, storedFields: Object.fromEntries(this._storedFields), index: u, serializationVersion: 1 } }, n.prototype.termResults = function (e, n, i, o, u, a, s) { var l, f, c, h, d; if (void 0 === u && (u = new Map), void 0 === a && (a = 1), void 0 === s && (s = 0), null == o) return u; try { for (var v = t(Object.keys(n)), y = v.next(); !y.done; y = v.next()) { var p = y.value, m = n[p], F = this._fieldIds[p], g = o.get(F); if (null != g) try { for (var x = (c = void 0, t(g.ds)), _ = x.next(); !_.done; _ = x.next()) { var A = r(_.value, 2), z = A[0], b = A[1], C = i ? i(this._documentIds.get(z), e) : 1; if (C) { var k = this._fieldLength.get(z)[F] / this._averageFieldLength[F], D = a * C * E(b, g.df, this._documentCount, k, m, s), I = u.get(z); if (I) { I.score += D; var M = w(I.match, e); M ? M.push(p) : (I.match[e] = [p], I.terms.push(e)) } else u.set(z, { score: D, match: (d = {}, d[e] = [p], d), terms: [e] }) } } } catch (e) { c = { error: e } } finally { try { _ && !_.done && (h = x.return) && h.call(x) } finally { if (c) throw c.error } } } } catch (e) { l = { error: e } } finally { try { y && !y.done && (f = v.return) && f.call(v) } finally { if (l) throw l.error } } return u }, n.prototype.addTerm = function (e, t, r) { var n = this._index.fetch(r, I), i = n.get(e); if (null == i) (i = { df: 1, ds: new Map }).ds.set(t, 1), n.set(e, i); else { var o = i.ds.get(t); null == o && (i.df += 1), i.ds.set(t, (o || 0) + 1) } }, n.prototype.removeTerm = function (e, t, r) { if (this._index.has(r)) { var n = this._index.fetch(r, I), i = n.get(e); null == i || null == i.ds.get(t) ? this.warnDocumentChanged(t, e, r) : i.ds.get(t) <= 1 ? i.df <= 1 ? n.delete(e) : (i.df -= 1, i.ds.delete(t)) : i.ds.set(t, i.ds.get(t) - 1), 0 === this._index.get(r).size && this._index.delete(r) } else this.warnDocumentChanged(t, e, r) }, n.prototype.warnDocumentChanged = function (e, r, n) { var i, o; if (null != console && null != console.warn) try { for (var u = t(Object.keys(this._fieldIds)), a = u.next(); !a.done; a = u.next()) { var s = a.value; if (this._fieldIds[s] === r) return void console.warn("MiniSearch: document with ID ".concat(this._documentIds.get(e), ' has changed before removal: term "').concat(n, '" was not present in field "').concat(s, '". Removing a document after it has changed can corrupt the index!')) } } catch (e) { i = { error: e } } finally { try { a && !a.done && (o = u.return) && o.call(u) } finally { if (i) throw i.error } } }, n.prototype.addDocumentId = function (e) { var t = this._nextId; return this._documentIds.set(t, e), this._documentCount += 1, this._nextId += 1, t }, n.prototype.addFields = function (e) { for (var t = 0; t < e.length; t++)this._fieldIds[e[t]] = t }, n.prototype.addFieldLength = function (e, t, r, n) { var i = this._fieldLength.get(e); null == i && this._fieldLength.set(e, i = []), i[t] = n; var o = (this._averageFieldLength[t] || 0) * r + n; this._averageFieldLength[t] = o / (r + 1) }, n.prototype.removeFieldLength = function (e, t, r, n) { var i = this._averageFieldLength[t] * r - n; this._averageFieldLength[t] = i / (r - 1) }, n.prototype.saveStoredFields = function (e, r) { var n, i, o = this._options, u = o.storeFields, a = o.extractField; if (null != u && 0 !== u.length) { var s = this._storedFields.get(e); null == s && this._storedFields.set(e, s = {}); try { for (var l = t(u), f = l.next(); !f.done; f = l.next()) { var c = f.value, h = a(r, c); void 0 !== h && (s[c] = h) } } catch (e) { n = { error: e } } finally { try { f && !f.done && (i = l.return) && i.call(l) } finally { if (n) throw n.error } } } }, n }(), w = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0 }, A = ((i = {}).or = function (e, i) { var o, u, a; try { for (var s = t(i.keys()), l = s.next(); !l.done; l = s.next()) { var f = l.value, c = e.get(f); if (null == c) e.set(f, i.get(f)); else { var h = i.get(f), d = h.score, v = h.match, y = h.terms; c.score = 1.5 * (c.score + d), c.match = Object.assign(c.match, v), (a = c.terms).push.apply(a, n([], r(y), !1)) } } } catch (e) { o = { error: e } } finally { try { l && !l.done && (u = s.return) && u.call(s) } finally { if (o) throw o.error } } return e }, i.and = function (e, i) { var o, u, a = new Map; try { for (var s = t(i.keys()), l = s.next(); !l.done; l = s.next()) { var f = l.value, c = e.get(f); if (null != c) { var h = i.get(f), d = h.score, v = h.match, y = h.terms; a.set(f, { score: c.score + d, match: Object.assign(c.match, v), terms: n(n([], r(c.terms), !1), r(y), !1) }) } } } catch (e) { o = { error: e } } finally { try { l && !l.done && (u = s.return) && u.call(s) } finally { if (o) throw o.error } } return a }, i.and_not = function (e, r) { var n, i; try { for (var o = t(r.keys()), u = o.next(); !u.done; u = o.next()) { var a = u.value; e.delete(a) } } catch (e) { n = { error: e } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } return e }, i), E = function (e, t, r, n, i, o) { var u, a; return i / (1 + .333 * i * o) * (u = t, a = r, e * Math.log(a / u)) / n }, z = function (e) { return function (t, r, n) { return { term: t, fuzzy: "function" == typeof e.fuzzy ? e.fuzzy(t, r, n) : e.fuzzy || !1, prefix: "function" == typeof e.prefix ? e.prefix(t, r, n) : !0 === e.prefix } } }, b = function (e) { return e.filter((function (e, t, r) { return r.indexOf(e) === t })) }, C = { idField: "id", extractField: function (e, t) { return e[t] }, tokenize: function (e, t) { return e.split(S) }, processTerm: function (e, t) { return e.toLowerCase() }, fields: void 0, searchOptions: void 0, storeFields: [] }, k = { combineWith: x, prefix: !1, fuzzy: !1, maxFuzzy: 6, boost: {}, weights: { fuzzy: .45, prefix: .375 } }, D = { prefix: function (e, t, r) { return t === r.length - 1 } }, I = function () { return new Map }, M = function (e) { var r, n, i = new Map; try { for (var o = t(Object.keys(e)), u = o.next(); !u.done; u = o.next()) { var a = u.value; i.set(parseInt(a, 10), e[a]) } } catch (e) { r = { error: e } } finally { try { u && !u.done && (n = o.return) && n.call(o) } finally { if (r) throw r.error } } return i }, S = /[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u; return _
}));
 //# sourceMappingURL=/sm/b7f8334c4d46253937e43f5eead8d4d068fd95430ba2f6ca03845e035a2f7025.map